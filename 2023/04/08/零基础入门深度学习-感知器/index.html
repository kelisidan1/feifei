<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>零基础入门深度学习-感知器 | Luke-blog</title>

  
  <meta name="author" content="John Doe">
  

  
  <meta name="description" content="0x1 理解链接：https://blog.csdn.net/u011681952/article/details/93633608我的理解： 核心是函数但是要对这个函数进行调参从而能实现线性分类或者线性回归问题e.g. and 函数、or 函数
0x2 从这节课当中学习到的知识
  填充list
">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="零基础入门深度学习-感知器"/>

  <meta property="og:site_name" content="Luke-blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Luke-blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Luke-blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>零基础入门深度学习-感知器</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/04/08/零基础入门深度学习-感知器/" rel="bookmark">
        <time class="entry-date published" datetime="2023-04-08T13:17:39.000Z">
          2023-04-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="0x1-理解"><a href="#0x1-理解" class="headerlink" title="0x1 理解"></a>0x1 理解</h2><p>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011681952/article/details/93633608">https://blog.csdn.net/u011681952/article/details/93633608</a><br>我的理解： 核心是函数<br>但是要对这个函数进行<mark>调参</mark><br>从而能实现线性分类或者线性回归问题<br>e.g. and 函数、or 函数</p>
<h2 id="0x2-从这节课当中学习到的知识"><a href="#0x2-从这节课当中学习到的知识" class="headerlink" title="0x2 从这节课当中学习到的知识"></a>0x2 从这节课当中学习到的知识</h2><blockquote>
<p>  填充list</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight = [0.0 for _ in range(10)]</span><br><span class="line">print(weight)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  python当中的类（类比Java学习）</p>
</blockquote>
<p><mark>核心：构造方法、this关键字</mark></p>
<p><img src="https://raw.githubusercontent.com/kelisidan1/blogImg/main/img/image-20230408200856228.png" alt="image-20230408200856228"></p>
<p><mark>类比：toString方法</mark></p>
<p><img src="https://raw.githubusercontent.com/kelisidan1/blogImg/main/img/image-20230408201327525.png" alt="image-20230408201327525"></p>
<p>这里有个知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\t 是指制表符，代表着四个空格，也就是一个tab</span><br><span class="line">%s %f 是字符串的格式方式</span><br><span class="line">self.weights会被填充到 %s的位置上</span><br><span class="line">self.bias 会被填充到 %f的位置上</span><br></pre></td></tr></table></figure>



<p><mark>普通方法：</mark></p>
<p><img src="https://raw.githubusercontent.com/kelisidan1/blogImg/main/img/image-20230408203210295.png" alt="image-20230408203210295"></p>
<p>这里有个知识点：</p>
<ul>
<li><p>activator是在构造函数中有定义，由于python没有数值的类型要求，所以不需要在函数内部再去单独定义这个类的变量</p>
</li>
<li><p>lambda表达式的使用</p>
<ul>
<li>lambda 参数：返回值	 <mark>e.g. lambda a,b:a+b</mark></li>
<li>写上它，就相当于说给了一个函数<ul>
<li>这个函数可以用在reduce函数当中，进行迭代（目前知道的用途）</li>
</ul>
</li>
</ul>
</li>
<li><p>map的使用</p>
<ul>
<li><p>map(function, iterable, …)</p>
</li>
<li><p>它返回的是一个Map对象，如果想要输出里面的内容，可以转成List集合进行输出</p>
</li>
<li><p>function —-&gt; 函数<br>iterable —-&gt; 一个或多个序列</p>
</li>
<li><p><mark>经典例子</mark></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;=一般写法：&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;=</span></span><br><span class="line"><span class="comment"># 1、计算平方数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])	<span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;=匿名函数写法：&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;</span></span><br><span class="line"><span class="comment"># 2、计算平方数，lambda 写法</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]	 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、提供两个列表，将其相同索引位置的列表元素进行相加</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>zip函数的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"> </span><br><span class="line">xyz = <span class="built_in">zip</span>(x, y, z)</span><br><span class="line"><span class="comment">#print xyz运行的结果是：</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce函数的使用</p>
<ul>
<li><p>描述：<strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p>
<p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
</li>
<li><p>&#96;&#96;&#96;python</p>
<h1 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h1><p>reduce(function, iterable[, initializer])</p>
<h1 id="function-–-函数，有两个参数"><a href="#function-–-函数，有两个参数" class="headerlink" title="function – 函数，有两个参数"></a>function – 函数，有两个参数</h1><h1 id="iterable-–-可迭代对象"><a href="#iterable-–-可迭代对象" class="headerlink" title="iterable – 可迭代对象"></a>iterable – 可迭代对象</h1><h1 id="initializer-–-可选，初始参数"><a href="#initializer-–-可选，初始参数" class="headerlink" title="initializer – 可选，初始参数"></a>initializer – 可选，初始参数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+   例子：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    #!/usr/bin/python</span><br><span class="line">    from functools import reduce</span><br><span class="line">    </span><br><span class="line">    def add(x, y) :            # 两数相加</span><br><span class="line">        return x + y</span><br><span class="line">    sum1 = reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5</span><br><span class="line">    sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数</span><br><span class="line">    print(sum1)  #15</span><br><span class="line">    print(sum2)  #15</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0x3-小Tips"><a href="#0x3-小Tips" class="headerlink" title="0x3 小Tips"></a>0x3 小Tips</h2><p>神经元也叫做<strong>感知器</strong></p>
<p><img src="https://raw.githubusercontent.com/kelisidan1/blogImg/main/img/image-20230409102928489.png" alt="image-20230409102928489"></p>
<p>每个小圈圈都是一个神经元（感知器）</p>
<p>但是每个感知器内部又是这样子：</p>
<p><img src="https://raw.githubusercontent.com/kelisidan1/blogImg/main/img/image-20230409103031661.png" alt="image-20230409103031661"></p>
<p>so，代码部分在干什么呢？</p>
<blockquote>
<p>  大步骤：</p>
<ol>
<li>训练感知器</li>
<li>训练好后，我把数据扔给感知器，让他输出结果</li>
</ol>
</blockquote>
<blockquote>
<p>  小步骤-怎么训练感知器？</p>
<ol>
<li><p>创建一个感知器 train_and_perceptron()</p>
</li>
<li><p><mark>十轮迭代训练，速率为0.1<mark>  p.train(input_vecs, labels, 10, 0.1)</p>
<p>每一轮干了这些事情：</p>
<ul>
<li>计算感知器在当前权重下的输出</li>
<li><mark>更新权重<mark></li>
</ul>
</li>
</ol>
</blockquote>
<p>解惑：</p>
<p>在感知器算法中，_update_weights函数是用来更新权重和偏置项的。在每次训练中，该函数会计算当前预测输出与实际标签之间的差异（即误差），并根据误差和学习速率来更新权重和偏置项。</p>
<p>具体来说，对于每个输入向量和对应的标签，算法计算当前输入向量对应的输出值，然后根据预测输出和实际标签之间的差异来计算更新量。对于每个输入向量的每个权重和偏置项，更新量都是根据以下公式计算的：</p>
<p><mark>w’ &#x3D; w + Δw &#x3D; w + η * δ * x b’ &#x3D; b + Δb &#x3D; b + η * δ</mark></p>
<p>其中，w是权重，b是偏置项，w’和b’是更新后的权重和偏置项，η是学习速率，δ是误差，x是当前输入向量的值。<mark>这个公式可以理解为：权重和偏置项的更新量与学习速率和误差成正比，与输入向量的值成正比。</mark></p>
<p>最终，_update_weights函数返回更新后的权重和偏置项。这些更新后的权重和偏置项将用于下一次迭代中，以继续训练模型。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 John Doe
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>